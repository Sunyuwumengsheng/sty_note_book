锁模型
![[Pasted image 20231204145128.png]]
*注意锁LR以及对应资源R之间的关系*




#### 死锁出现的条件
__一组互相竞争资源的线程互相等待导致的永久等待现象__
如果线程T1 和T2 需要操作A ->B  B->A 如果T1获取了对象A T2获取了对象B T1需要B 所以阻塞等待，T2也处于等待状态 ，如果没有外部条件破坏T1和T2会永久阻塞等待形成死锁

* 互斥共享资源X和Y只能被一个线程占用
* 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X
* 不可抢占，其他线程不能强行抢占线程 T1 占有的资源
* 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待
互斥是必要条件，使用是锁本就是互斥
第二条只要能够一次申请所有的资源，就不存在资源等待问题
第三条对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。
第四条：对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。

#### 使用锁需要将锁能覆盖所保护的资源就行锁的颗粒度问题

### 等待通知
一个完整的等待 - 通知机制：线程首先获取互斥锁，当线程要求的条件不满足时，释放互斥锁，进入等待状态；当要求的条件满足时，通知等待的线程，重新获取互斥锁

这边会涉及到三个方法
wait(),notify(),notifyAll()

`wait()`、`notify()` 和 `notifyAll()` 是 Java 中用于线程间通信的方法。它们用于协调多个线程之间的执行顺序，以避免竞态条件和死锁等问题。

- `wait()` 方法用于使当前线程进入等待状态，直到其他线程调用该对象的 `notify()` 或 `notifyAll()` 方法来唤醒它。
- `notify()` 方法用于唤醒正在等待该对象锁的单个线程，如果有多个线程在等待，则只会唤醒其中一个线程。
- `notifyAll()` 方法用于唤醒正在等待该对象锁的所有线程。

使用这三个方法时需要注意以下几点：

1. 这些方法必须在同步代码块或同步方法中被调用，因为它们要求获取对象的监视器锁。
2. 调用 `wait()` 方法后，当前线程会释放对象的监视器锁，并进入等待状态，直到被其他线程唤醒。
3. 当线程被唤醒后，它会重新尝试获取对象的监视器锁，一旦成功获取，线程会继续执行。
4. 在调用 `wait()` 方法后，线程会暂停执行并释放 CPU 资源，但不会释放持有的其他锁。
5. `notify()` 和 `notifyAll()` 方法只是唤醒等待队列中的线程，不会释放对象锁。被唤醒的线程会在获取到该对象锁后继续执行。
6. `notify()` 方法只会随机唤醒等待队列中的一个线程，而 `notifyAll()` 方法会唤醒所有等待线程。
7. 唤醒的线程需要重新进入竞争状态以获得锁，因此调用 `wait()` 后的线程可能不会立即被唤醒。


注意notify()可能会导致某个线程无法被唤醒（简单来说随机随不到）因此尽量使用notifyAll()

